如何让程序跑起来：
   1.在程序中找到一个空闲的内存单元 拿出空闲单元的基地址 赋值给进程的pcb
   2.切换根据 switch_to 切换到对应的进程去执行 执行指令 进行地址翻译

所以，内存对齐最最底层的原因是内存的IO是以8个字节64bit为单位进行的。 对于64位数据宽度的内存，
假如cpu也是64位的cpu（现在的计算机基本都是这样的），每次内存IO获取数据都是从同行同列的8个bank中各自读取一个字节拼起来的
。从内存的0地址开始，0-7字节的数据可以一次IO读取出来，8-15字节的数据也可以一次读取出来。

换个例子，假如你指定要获取的是0x0001-0x0008，也是8字节，但是不是0开头的，内存需要怎么工作呢？没有好办法，
内存只好先工作一次把0x0000-0x0007取出来，然后再把0x0008-0x0015取出来，把两次的结果都返回给你。
CPU和内存IO的硬件限制导致没办法一次跨在两个数据宽度中间进行IO。这样你的应用程序就会变慢，算是计算机因为你不懂
内存对齐而给你的一点点惩罚。


扩展1：事实上，编译和链接器会自动替开发者对齐内存的，尽量帮你保证一个变量不跨列寻址。但是他不能做到十分完美。

扩展2：其实在内存硬件层上，还有操作系统层。操作系统还管理了CPU的一级、二级、三级缓存。不知道你有没有印象，
       我们前面的文章说过高速缓存里的Cache Line是64字节，它是内存IO单位的8倍，不会让内存IO浪费。