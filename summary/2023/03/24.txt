1.服务器出现大量 CLOSE_WAIT 状态的原因有哪些？

close_wait 状态是被动关闭的一方才有的，而且如果被关闭的一方 没有调用close()函数 那个操作系统就不会发送fin 报文
，从而无法使的close_wait 的状态连接转化为 last_ack状态,所以说，当服务端出现大量的close_wait 时候，说明服务端没有调用close函数关闭连接。


2.如果已经建立了连接，但是客户端突然出现故障了怎么办？
客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 ESTABLISH 状态，占用着系统资源。

3.为了避免这种情况，TCP 搞了个保活机制。(保活机制)

4.TCP 保活的这个机制检测的时间是有点长，我们可以自己在应用层实现一个心跳机制。

比如，web 服务软件一般都会提供 keepalive_timeout 参数，用来指定 HTTP 长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会启动一个定时器，如果客户端在完成一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，就会触发回调函数来释放该连接。

5.如果已经建立了连接，但是服务端的进程崩溃会发生什么？
TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。
