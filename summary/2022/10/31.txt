一、服务器的 listen=>:

   总结一下，客户端在 connect 的时候，把本地 socket 状态设置成了 
   TCP_SYN_SENT，选了一个可用的端口，接着发出 SYN 握手请求并启动重传定时器。

二、客户端 connect=>:
   总结一下，客户端在 connect 的时候，把本地 socket 状态设置成了 TCP_SYN_SENT，选了一个可用的端口，
   接着发出 SYN 握手请求并启动重传定时器。
三、服务器响应 SYN =>：

 总结一下，服务器响应 ack 是主要工作是判断下接收队列是否满了，满的话可能会丢弃该请求，否则发出 synack。
    申请 request_sock 添加到半连接队列中，同时启动定时器。

四、客户端响应 SYNACK=>:

   客户端响应来自服务器端的 synack 时清除了 connect 时设置的重传定时器，把当前 socket 状态设置为 ESTABLISHED，
     开启保活计时器后发出第三次握手的 ack 确认。

五、服务器响应 ACK =>:
      服务器响应第三次握手 ack 所做的工作是把当前半连接对象删除，创建了新的 sock 后加入到全连接队列中，
      最后将新连接状态设置为 ESTABLISHED。

六、服务器 accept =>:
     accept 的重点工作就是从已经建立好的全连接队列中取出一个返回给用户进程


大总结:
    1. 服务器 listen 时，计算了全/半连接队列的长度，还申请了相关内存并初始化。
    2. 客户端 connect 时，把本地 socket 状态设置成了 TCP_SYN_SENT，选则一个可用的端口，发出 SYN 握手请求并启动重传定时器。
    3. 服务器响应 ack 时，会判断下接收队列是否满了，满的话可能会丢弃该请求。否则发出 synack，
       申请 request_sock 添加到半连接队列中，同时启动定时器。
    4. 客户端响应 synack 时，清除了 connect 时设置的重传定时器，把当前 socket 状态设置为 ESTABLISHED，
       开启保活计时器后发出第三次握手的 ack 确认。
    5. 服务器响应 ack 时，把对应半连接对象删除，创建了新的 sock 后加入到全连接队列中，最后将新连接状态设置为 ESTABLISHED。
    6. accept 从已经建立好的全连接队列中取出一个返回给用户进程。


