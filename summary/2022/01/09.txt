1.当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）
等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的
事件处理器来处理这些事件。也称之为reactor模型 也就是事件驱动模型

2.fork 赋值进程 复制的意思

3.当子进程退出时 回向父进程发送中断信号 sighld

4.php 执行的echo  系统会调用  write 函数 打印大屏幕上

5.ps -eF |grep 对应的文件

6.cat /proc/cpuinfo(查看CPU的详细信息)  lscpu (查看CPU的核心数)

1.下图分别对应传统 I/O 操作的数据读写流程，整个过程涉及 2 次 CPU 拷贝、2 次 DMA 拷贝，总共 4 次拷贝，以及 4 次上下文切换。

CPU 拷贝：

由 CPU 直接处理数据的传送，数据拷贝时会一直占用 CPU 的资源。

DMA 拷贝：

由 CPU 向DMA磁盘控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，从而减轻了 CPU 资源的占有率。

上下文切换：

当用户程序向内核发起系统调用时，CPU 将用户进程从用户态切换到内核态；

当系统调用返回时，CPU 将用户进程从内核态切换回用户态。
对应的图片是IO_read =


IO写操作

写操作
当应用程序准备好数据，执行 write 系统调用发送网络数据时，先将数据从用户空间的页缓存拷贝到内核空间的网络缓冲区（Socket Buffer）中，然后再将写缓存中的数据拷贝到网卡设备完成数据发送。

write(socket_fd, tmp_buf, len);
基于传统的 I/O 写入方式，write() 系统调用会触发 2 次上下文切换，1 次 CPU 拷贝和 1 次 DMA 拷贝。

用户程序发送网络数据的流程如下：

用户进程通过 write() 函数向 kernel 发起 System Call，上下文从 user space 切换为 kernel space。

CPU 将用户缓冲区（User Buffer）中的数据拷贝到 kernel space 的网络缓冲区（Socket Buffer）。

CPU 利用 DMA 控制器将数据从网络缓冲区（Socket Buffer）拷贝到 NIC 进行数据传输。

上下文从 kernel space 切换回 user space，write 系统调用执行返回。

对用的read_IO

页缓存读取策略：当进程发起一个读操作 （比如，进程发起一个 read() 系统调用），它首先会检查需要的数据是否在页缓存中：

如果在，则放弃访问磁盘，而直接从页缓存中读取。

如果不在，则内核调度块 I/O 操作从磁盘去读取数据，并读入紧随其后的少数几个页面（不少于一个页面，通常是三个页面），
然后将数据放入页缓存中。 也就是缓存预读
