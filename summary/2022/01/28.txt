1.CPU运行的前提:
    而在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好
 CPU 寄存器和程序计数器 （CPU的寄存器和程序计数器）

2. 上下文切换:
   CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储CPU 正在执行的指令位置、
   或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文

3.上下文切换的内容 实质上是 CPU寄存器和程序计数器的切换

  CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加
 载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

 4.为什么需要是那个下文切换:
    
    进程切换时才需要切换上下文，换句话说，只有在进程调度的时候，才需要切换上下文。Linux 为每个 CPU 都维护了一个就绪队列，
    将活跃进程（即正在运行和正在等待CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，
    也就是优先级最高和等待 CPU 时间最长的进程来运行

5.进程什么时候才会被调度到CPU上运行
   就是进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行。其实还有很多其他场景，
   也会触发进程调度，在这里我给你逐个梳理下。
   其一，为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，
   当某个进程的时间片耗尽了，就会被系统挂起，切
   换到其它正在等待 CPU 的进程运行。
   其二，进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。

  其三，当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。
  其四，当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。
  其五，发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。

6.怎么查看进程的上下文切换:
   使用 vmstat 这个工具，来查询系统的上下文切换情况 ,主要关注以下几项
   cswch ，表示每秒自愿上下文切换(voluntary context switches）的次数，

    nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数

    所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说，
    I/O、内存等系统资源不足时，就会发生自愿上下文切换。
    而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生
    的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换
   使用pidstat查看上下文切换的情况
