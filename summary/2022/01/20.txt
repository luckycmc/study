上下文简介
context:上下文切换
   首先要理解boost::context的概念和应用场景。程序在执行的时候，当前的执行的代码环境和所处的状态，就是context。
boost::context保留了当前程序执行时的寄存器等的状态，可以认为是一个上下文A；然后线程就可以去执行其他的代码，完
成执行后，可以切回上下文A，并从当初切走的地方执行，而且当初的上下文的现场不变，这就是完成了一次真正意义上的上下文切换。

   上线文切换，在协程和用户态线程等有重要的意义（统称它们为routine），我们可以启动一定数量的操作系统的线程，
然后让routine在OS的thread中切换，切换时仅需要保留有关的上下文即可，通过一定的调度方式，
是的OS的Thread不停的执行这些routine。routine的切换速度，远远快于thread，可极大提高效率。
//  pidstat :查看进程的相关切换信息
/**************汇编的基础知识 start*****************/
%rax 一般用作累加器(Accumulator)
%rbx 一般用作基址寄存器( Base )
%rxc 一般用来计数( Count )
%rdx 一般用来存放数据( Data )
%rsi一般用作源变址( Source Index )
%rdi 一般用作目标变址( DestinatinIndex )
%rbp 一般用作基址指针( Base Pointer )
%rsp 一般用作堆栈指针( Stack Pointer )


%rip 是指令指针，也称为 PC指针




1.PC（program counter）是CPU中用于存放下一条指令地址的寄存器，SP为堆栈指针

2.PC：Program Counter，是通用寄存器，但是有特殊用途，用来指向当前运行指令的下一条指令。

3.SP：Stack Pointer，堆栈指针，也是通用寄存器，用于入栈和出栈操作。

4.栈 在内存中的原理:
    栈顶的地址要小于栈底的地址，所以栈是从高地址向低地址生长。栈是从高地址向低地址生长的，既栈底在高地址，栈顶低地址。
    也就是说 数据入栈的时候 栈顶往下低地址空间移动,栈顶不变

5.总之，linux任务用户态的堆栈和普通应用程序一样，由操作系统分配和释放，对程序员来说不可见，
        不过因为操作系统的原因，任务用户程序寻址有限制。

6.栈帧
   栈帧，也就是stack frame，其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）
   。栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP(栈指针)就是一直指向栈顶的。
   我们用 %ebp 指向栈底，也就是基址指针；用 %esp 指向栈顶，也就是栈指针。 
/**************汇编的基础知识 end*****************/