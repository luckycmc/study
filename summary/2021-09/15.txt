1.内存池直接代替了 传统的malloc /free，calloc 等方法然后进程内存管理，当我们申请内存的时候 首先到我们的内存池查找合适的内存块
  而不是想操作系统申请内存
  优势：
      A.比malloc/free 进行内存申请和释放的方式快
      B.降低使用和产生内存堆分片
      C.可避免内存泄露



那么调用malloc时底层都发生了什么呢？简单来说会有这样典型的几个步骤：

 1.malloc开始搜索空闲内存块，如果能找到一块大小合适的就分配出去如果malloc找不到一块合适的空闲内存，
 2.那么调用brk等系统调用扩大堆区从而获得更多的空闲内存malloc调用brk后开始转入内核态，

 3.此时操作系统中的虚拟内存系统开始工作，扩大进程的堆区，注意额外扩大的这一部分内存仅仅是虚拟内存，
 操作系统并没有为此分配真正的物理内存brk执行结束后返回到malloc，从内核态切换到用户态，
 malloc找到一块合适的空闲内存后返回

1.当malloc返回后，程序员申请到的内存就是虚拟内存
   标准库是用户态的 可以适用不同的操作系统 这样程序员写的程序无需无需修改在不同的操作系统上运行了再C语言中这就是所谓的标准库

2.内存分配 

  Windows：在默认情况下会将高地址的 2GB 空间分配给内核（也可以配置为1GB）。
  Linux： 默认情况下会将高地址的 1GB 空间分配给内核。

  内核空间:

    分配给内核的这段空间成为内核空间。
    为了安全，只能借助系统API来访问你自己，这个API函数俗称为 System Call

  用户空间:

    应用程序只能使用剩下的 2GB 或 3GB 的地址空间，称为用户空间（User Space）。

  3.为什么内核空间和用户空间要放到一个地址空间中，单独给内核空间一段地址空间不行么？

    内核用有自己独立的地址空间让内核处于一个独立的进程中，

    这样每次进行系统调用都需要切换进程。切换进程的消耗是巨大的，不仅需要寄存器进栈出栈，还会使CPU中的数据缓存失效、
    MMU中的页表缓存失效，这将导致内存的访问在一段时间内相当低效。

    而让内核和用户程序共享地址空间，发生系统调用时进行的是模式切换，模式切换仅仅需要寄存器进栈出栈，不会导致缓存失效；
    现代CPU也都提供了快速进出内核模式的指令，与进程切换比起来，效率大大提高了。
    
  4.MMU：内存管理单元，负责虚拟地址映射为物理地址。

    虚拟地址：现代操作系统都使用分页机制来管理内存，这使得每个程序都拥有自己的地址空间。每当程序使用虚拟地址进行读写时，
    都必须转换为实际的物理地址，才能真正在内存条上定位数据。
  
//目标要分析两个软件的内存池 
  1.PHP  2.nginx 这也是工作中常用的技术软件