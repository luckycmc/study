1.网络编程的总结
  1.server 端的socket总结

     socket()
     bind() 
     listen()  //产生半个连接队列syn_queue
     accept()  //产生全连接队列all_queue  里面的fd 也就是和客户端交互的fd 
     read()    //读取网络的请求数据 默认为阻塞的 也可以设置为非阻塞的
     write()   //把数据返回个客户端,通过fd 写会之前的fd
     close()   //关闭断开的fd连接

  2.网络IO模型
    1.阻塞IO
       数据要经历两个阶段
       1.网络数据准备阶段 内核需要读取对应的网络数据,读取完毕，然后用户态程序从内核copy到用户态，两个阶段都是阻塞的
       常用的网络模型例如PHP的  PHP-fpm
       
2.操作系统的总结
     1.常用的io函数总结
     //C语言代码

     int main()
      {
         int sk = socket(AF_INET, SOCK_STREAM, 0);
         connect(sk, ...)
         recv(sk, ...)
      }
      但是在高并发的服务器开发中，这种网络 IO 的性能奇差。因为
      1.进程在recv的时候大概率会被阻塞掉,导致一次进程切换
      2.当连接上数据就绪时进程又被唤醒,又是一次进程切换
      3.一个进程同时只能等待一条连接,如果并发很大则需要更多的进程

      常用的解决方案是:多进程和多线程解决方案 来应对 相对规模的高并发请求

      总结:
         第一部分是我们自己代码所在的进程，我们调用的 socket() 函数会进入内核态创建必要内核对象。
         recv() 函数在进入内核态以后负责查看接收队列，以及在没有数据可处理的时候把当前进程阻塞掉，让出 CPU。

         第二部分是硬中断、软中断上下文（系统进程 ksoftirqd）。在这些组件中，将包处理完后会放到 socket 的接收队列中。
         然后再根据 socket 内核对象找到其等待队列中正在因为等待而被阻塞掉的进程，然后把它唤醒。


   2.IO多路复用:

          这里的复用指的就是对进程或者线程的复用
          当 accept 之后，进程会创建一个新的 socket 出来，专门用于和对应的客户端通信，然后把它放到当前进程的打开文件列表中
          socket  会产生对应你的fd 把这个fd放入到当前进程的文件描述符中 用户和客户端通讯
          //socket 的创建过程:

          1.1 初始化 struct socket 对象(其实 file 对象内部也有一个 socket 指针，指向 socket 对象。)

          1.2 为新 socket 对象申请 file

            struct socket 对象中有一个重要的成员 -- file 内核对象指针。这个指针初始化的时候是空的。
            在 accept 方法里会调用 sock_alloc_file 来申请内存并初始化。然后将新 file 对象设置到 sock->file 上。
         
          1.3 接收连接
             在 socket 内核对象中除了 file 对象指针以外，有一个核心成员 sock。

          1.4 添加新文件到当前进程的打开文件列表中
            当 file、socket、sock 等关键内核对象创建完毕以后，剩下要做的一件事情就是把它挂到当前进程的打开文件列表中就行了。
         

    当没有 IO 事件的时候， epoll 也是会阻塞掉当前进程。这个是合理的，因为没有事情可做了占着 CPU 也没啥意义。