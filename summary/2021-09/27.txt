TCP三次握手异常:
    一、客户端 connect 异常
      客户端在发起 connect 系统调用的时候，主要工作就是端口选择,如果没有端口可用可能也会发生异常
      
    二、第一次握手丢包

      2.1 半连接队列满
         如果半连接队列满了，而且 ipv4.tcp_syncookies 参数设置为 0，那么来自客户端的握手包将 goto drop，意思就是直接丢弃！
      
      2.2 全连接队列满
         
         当半连接队列判断通过以后，紧接着还有全连接队列满的相关判断。如果这个条件成立，
         服务器对握手包的处理还是会 goto drop，丢弃了之。
     
         假如全连接队列满的情况下，且同时有 young_ack ，那么内核同样直接丢掉该 SYN 握手包。

      2.3 客户端发起重试
          
          好在客户端在发出握手包的时候，开启了一个重传定时器。如果收不到预期的 synack 的话，超时重传的逻辑就会开始执行。
          不过重传计时器的时间单位都是以秒来计算的，这意味着，如果有握手重传发生，即使第一次重传就能成功，
          那接口最快响应也是 1 s 以后的事情了。这对接口耗时影响非常的大
      
         假如我们服务器上在第一次握手的时候出现了半/全连接队列溢出导致的丢包，那么我们的接口响应时间将至少是 1 s 以上
         （在某些老版本的内核上，SYN 第一次的重试就需要等 3 秒），如果连续两三次握手都失败，那 7，8 秒就出去了。
         你想想这对用户是不是影响很大。
        

    三、第三次握手丢包
        
        /file: net/ipv4/tcp_ipv4.c
        struct sock *tcp_v4_syn_recv_sock(struct sock *sk, ...)
        {    
            //判断接收队列是不是满了
            if (sk_acceptq_is_full(sk))
                goto exit_overflow;
            ...
        exit_overflow:
        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
        ...
        }

       从上述代码可以看出，第三次握手时，如果服务器全连接队列满了，来自客户端的 ack 握手包又被直接丢弃了。
       三次握手完的请求是要放在全连接队列里的。但是假如全连接队列满了，仍然三次握手也不会成功。

       第一个红框内是第三次握手，其实这个握手请求在服务器端以及被丢弃了。但是这时候客户端并不知情，
       它一直傻傻地以为三次握手已经妥了呢。不过还好，
       这时在服务器的半连接队列中仍然记录着第一次握手时存的握手请求。

      服务器等到半连接定时器到时后，向客户端重新发起 synack ，客户端收到后再重新回复第三次握手 ack。
      如果这期间服务器端全连接队列一直都是满的，那么服务器重试 5 次（受内核参数 net.ipv4.tcp_synack_retries 控制）
      后就放弃了。

      在这种情况下大家还要注意另外一个问题。在实践中，客户端往往是以为连接建立成功就会开始发送数据，
      其实这时候连接还没有真的建立起来。他发出去的数据，包括重试都将全部被服务器无视。
      直到连接真正建立成功后才行。

    四、总结
       
       今天的文章主要是描述了端口不足、半连接队列满、全连接队列满时的情况，
       当端口不充足的时候，会导致 connect 系统调用的时候过多地执行自旋锁等待与 Hash 查找，会引起 CPU 开销上涨。
       严重情况下会耗光 CPU，影响用户业务逻辑的执行。出现这种问题处理起来方法有这么几个。

        通过调整 ip_local_port_range 来尽量加大端口范围
        尽量复用连接，使用长连接来削减频繁的握手处理
        第三个有用，但是不太推荐的是开启 tcp_tw_reuse 和 tcp_tw_recycle
      
      服务器端在第一次握手时可能会丢包， 在如下两种情况下会发生。

     半连接队列满，且 tcp_syncookies 为 0
     全连接队列满，且有未完成的半连接请求
     在这两种情况下，客户端视角来看和网络断了没有区别，就是发出去的 SYN 包没有任何反馈，然后等待定时器到时后重传握手请求。
     第一次重传时间是 1 s ，接下来的等待间隔是翻倍地增长，2 s，4 s，8 s ...。总的重传次数由 net.ipv4.tcp_syn_retries 
     内核参数影响（注意我的用词是影响，而不是决定）。

     服务器在第三次握手时也可能会出问题，如果全连接队列满，仍将会发生丢包。不过第三次握手失败时，只有服务器端知道
     （客户端误以为连接已经建立成功了）。服务器根据半连接队列里的握手信息发起 synack 重试，
     重试次数由 net.ipv4.tcp_synack_retries 控制。

     一旦你的线上出现了上面这些连接队列溢出导致的问题，你的服务将会受到比较严重的影响。即使第一次重试就能够成功，
     那你的接口响应耗时将直接上涨到 1 s（老版本上是 3 s）。如果重试上两三次都没有成功，
     Nginx 很有可能直接就报访问超时失败了

     方法1，打开 syncookie  常用的解决方案:

        在现代的 Linux 版本里，我们可以通过打开 tcp_syncookies 来防止过多的请求打满半连接队列包括 SYN Flood 攻击，
        来解决服务器因为半连接队列满而发生的丢包

    方法2，加大连接队列长度

        我们讨论过全连接队列的长度是 min(backlog, net.core.somaxconn)半连接队列长度是。半连接队列长度有点小复杂，
        是 min(backlog, somaxconn, tcp_max_syn_backlog) + 1 再上取整到 2 的幂次，但最小不能小于16。

        如果需要加大全/半连接队列长度，请调节以上的一个或多个参数来达到目的。只要队列长度合适，
        就能很大程序降低握手异常概率的发生。

    方法3，尽快地 accept

        另外这个虽然一般不会成为问题，但也要注意一下。你的应用程序应该尽快在握手成功之后通过 accept 把新连接取走。
        不要忙于处理其它业务逻辑而导致全连接队列塞满了。
        
    方法4，尽量减少 TCP 连接的次数

        如果上述方法都未能根治你的问题，那说明你的服务器上 TCP 连接请求太、太过于频繁了。这个时候你应该思考下是否
        可以用长连接代替短连接，减少过于频繁的三次握手。这个方法不但能解决握手出问题的可能，而且还顺带砍掉了三次握手
        的各种内存、CPU、时间上的开销，对提升性能也有较大帮助。